<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-18T20:08:08+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mark Olenik</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Test GitHub Actions with `act` locally</title><link href="http://localhost:4000/2023/08/17/test-github-actions-with-act-locally.html" rel="alternate" type="text/html" title="Test GitHub Actions with `act` locally" /><published>2023-08-17T17:14:00+02:00</published><updated>2023-08-17T17:14:00+02:00</updated><id>http://localhost:4000/2023/08/17/test-github-actions-with-act-locally</id><content type="html" xml:base="http://localhost:4000/2023/08/17/test-github-actions-with-act-locally.html"></content><author><name>markolenik</name></author><summary type="html"></summary></entry><entry><title type="html">Multi-arch Docker Builds</title><link href="http://localhost:4000/2023/08/17/multi-arch-docker-builds.html" rel="alternate" type="text/html" title="Multi-arch Docker Builds" /><published>2023-08-17T17:14:00+02:00</published><updated>2023-08-17T17:14:00+02:00</updated><id>http://localhost:4000/2023/08/17/multi-arch-docker-builds</id><content type="html" xml:base="http://localhost:4000/2023/08/17/multi-arch-docker-builds.html">&lt;p&gt;In the process of developing a solid reproducible research pipeline for R, I was surprised to learn that robust reproducibility requires multi-arch Docker builds.
I was even more surprised to learn that building multi-arch Docker images is not as straightforward as I had hoped.
Here’s is a summary of my findings.&lt;/p&gt;

&lt;h1 id=&quot;multi-arch-images&quot;&gt;Multi-arch images&lt;/h1&gt;
&lt;p&gt;Most of my prototyping is done on a Macbook Pro with an M1 processor (ARM64 chip), compute intensive tasks are run on an Intel Xeon server (AMD64 chip).
When building with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker build .&lt;/code&gt; docker will build an image for the architecture of the host machine.
This means that if I build an image on my M1 Macbook Pro, the image will not run on the Intel Xeon server, which is a problem.&lt;/p&gt;

&lt;p&gt;The solution is multi-arch images.
A multi-arch image uses a so called “manifest” that contains the image for each architecture.
When the multi-arch image is pulled, docker will automatically select the correct image for the architecture of the host machine.&lt;/p&gt;

&lt;h1 id=&quot;how-to-build-multi-arch-images&quot;&gt;How to build multi-arch images&lt;/h1&gt;
&lt;p&gt;There are two ways to build multi-arch images, use Docker’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buildx&lt;/code&gt;, or manually build and push the image for each architecture.&lt;/p&gt;

&lt;h2 id=&quot;buildx-approach&quot;&gt;Buildx approach&lt;/h2&gt;
&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buildx&lt;/code&gt; method is the easier of the two, it builds and pushes the multi-arch image in a single command, and the images for each architecture are built in concurrently.
It requires a builder that supports multi-arch, which can be created with&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker buildx create --name multi-arch-builder --bootstrap --use
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Building and pushing the multi-arch image is then done with a single command:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker buildx build --push --platform linux/arm64,linux/amd64 -t &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I encountered a couple issues with this method, which is why right now I prefer the old and manual approach.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Currently the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buildx&lt;/code&gt; method requires that building and pushing happens in a single command (see &lt;a href=&quot;https://github.com/docker/buildx/issues/1152&quot;&gt;this issue&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;There’s no automatic caching of intermediate layers.
Even if your build succeeds but the push fails, you have to start from scratch.
There’s a manual workaround for this, but it’s not ideal (see &lt;a href=&quot;https://github.com/docker/buildx/discussions/1382&quot;&gt;this discusssion&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Podman doesn’t support multi-arch &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buildx&lt;/code&gt; yet (which might change in the future).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;manual-approach&quot;&gt;Manual approach&lt;/h2&gt;
&lt;p&gt;The old and manual approach works with both Docker and Podman.
It involves the following steps:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Build the image for each architecture.&lt;/li&gt;
  &lt;li&gt;Push the image for each architecture.&lt;/li&gt;
  &lt;li&gt;Create a manifest that contains both images.&lt;/li&gt;
  &lt;li&gt;Push manifest to the registry.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Building for both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARM64&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AMD64&lt;/code&gt; can be done with the following commands:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Build images
docker build --platform linux/arm64 -t &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;-arm64 .
docker build --platform linux/amd64 -t &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;-amd64 .

# Push images
docker push &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;-arm64
docker push &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;-amd64

# Create manifest
docker manifest create &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt; &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;-arm64 &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;-amd64

# Push manifest
docker manifest push &amp;lt;registry&amp;gt;/&amp;lt;namespace&amp;gt;/&amp;lt;package&amp;gt;:&amp;lt;tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;sources&quot;&gt;Sources&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.thorsten-hans.com/how-to-build-multi-arch-docker-images-with-ease/&lt;/li&gt;
  &lt;li&gt;https://www.docker.com/blog/how-to-rapidly-build-multi-architecture-images-with-buildx/&lt;/li&gt;
&lt;/ul&gt;</content><author><name>markolenik</name></author><summary type="html">In the process of developing a solid reproducible research pipeline for R, I was surprised to learn that robust reproducibility requires multi-arch Docker builds. I was even more surprised to learn that building multi-arch Docker images is not as straightforward as I had hoped. Here’s is a summary of my findings.</summary></entry></feed>